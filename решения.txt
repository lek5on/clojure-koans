1
(= true true)
(= 2 (+ 1 1))
(= (+ 3 4) 7 (+ 2 5))
(= true (= 2 2/1))
(= false (= 2 2.0))
(= true (== 2.0 2))
(= true (not (= 1 nil)))
(= false (= "hello" :hello 'hello))
(= :hello (keyword :hello))
(= 'hello (symbol "hello"))
(=  nil)
(not= :fill-in-the-blank 123))
2
(= "hello" "hello")
(= "world" (str 'world))
(= "Cool right?" (str 'Cool" "'right?))
(= \C (get "Characters" 0))
(= 11 (count "Hello World"))
(= false (= \c "c"))
(= "World" (subs "Hello World" "Hello "))
(= "123" (string/join '(1 2 3)))
(= "1, 2, 3" (clojure.string/join ", " '(1 2 3))))
(= ["1" "2" "3"] (clojure.string/split-lines "1\n2\n3"))
(= "olleh" (clojure.string/reverse "hello"))
(= 0 (clojure.string/index-of "hello world" "h"))
(= 13 (clojure.string/last-index-of "hello world, hello" "hello"))
(= nil (clojure.string/index-of "hello world" "bob"))
(= "hello world" (clojure.string/trim "  \nhello world \t \n"))
(= true (char? \c))
(= false (char? "a"))
(= false (string? \b))
(= true (string? "123asd"))
(= true (clojure.string/blank? ""))
(= true (clojure.string/blank? " \n \t  "))
(= false (clojure.string/blank? "hello?\nare you out there?")))

3

(= '(1,2,3,4,5) (list 1 2 3 4 5))
(= 1 (first '(1 2 3 4 5)))
(= __ (rest '(1 2 3 4 5)))
(= '(2 3 4 5) (rest '(1 2 3 4 5)))
(= 3 (count '(dracula dooku chocula)))
(= 0 (count '()))
(= '() (rest '(100)))
(= '(:a :b :c :d :e) (cons :a '(:b :c :d :e)))
(= '(:e :a :b :c :d) (conj '(:a :b :c :d) :e))
(= :a (peek '(:a :b :c :d :e)))
(= '(:b :c :d :e) (pop '(:a :b :c :d :e)))
(= "No dice!" (try
          (pop '())
          (catch IllegalStateException e
            "No dice!")))
(= '() (try
          (rest '())
          (catch IllegalStateException e
            "No dice!"))))

4

(= 1 (count [42]))
(= [1] (vec '(1)))
(= [nil,nil] (vector nil nil))
(= [1 2] (vec '(1 2)))
(= [111 222 333] (conj [111 222] 333))
(= :peanut (first [:peanut :butter :and :jelly]))
(= :jelly (last [:peanut :butter :and :jelly]))
(= :jelly (nth [:peanut :butter :and :jelly] 3))
(= [:butter :and] (subvec [:peanut :butter :and :jelly] 1 3))
(= (list 1 2 3) (vector 1 2 3)))

5

(= #{3} (set '(3)))
(= 3 (count #{1 2 3}))
(= #{1 2 3 4 5} (set '(1 1 2 2 3 3 4 4 5 5)))
(= #{1 2 3 4 5} (set/union #{1 2 3 4} #{2 3 5}))