;;1
(= true true)
(= 2 (+ 1 1))
(= (+ 3 4) 7 (+ 2 5))
(= true (= 2 2/1))
(= false (= 2 2.0))
(= true (== 2.0 2))
(= true (not (= 1 nil)))
(= false (= "hello" :hello 'hello))
(= :hello (keyword :hello))
(= 'hello (symbol "hello"))
(=  nil)
(not= :fill-in-the-blank 123))
;;2
(= "hello" "hello")
(= "world" (str 'world))
(= "Cool right?" (str 'Cool" "'right?))
(= \C (get "Characters" 0))
(= 11 (count "Hello World"))
(= false (= \c "c"))
(= "World" (subs "Hello World" "Hello "))
(= "123" (string/join '(1 2 3)))
(= "1, 2, 3" (clojure.string/join ", " '(1 2 3))))
(= ["1" "2" "3"] (clojure.string/split-lines "1\n2\n3"))
(= "olleh" (clojure.string/reverse "hello"))
(= 0 (clojure.string/index-of "hello world" "h"))
(= 13 (clojure.string/last-index-of "hello world, hello" "hello"))
(= nil (clojure.string/index-of "hello world" "bob"))
(= "hello world" (clojure.string/trim "  \nhello world \t \n"))
(= true (char? \c))
(= false (char? "a"))
(= false (string? \b))
(= true (string? "123asd"))
(= true (clojure.string/blank? ""))
(= true (clojure.string/blank? " \n \t  "))
(= false (clojure.string/blank? "hello?\nare you out there?")))

;;3

(= '(1,2,3,4,5) (list 1 2 3 4 5))
(= 1 (first '(1 2 3 4 5)))
(= __ (rest '(1 2 3 4 5)))
(= '(2 3 4 5) (rest '(1 2 3 4 5)))
(= 3 (count '(dracula dooku chocula)))
(= 0 (count '()))
(= '() (rest '(100)))
(= '(:a :b :c :d :e) (cons :a '(:b :c :d :e)))
(= '(:e :a :b :c :d) (conj '(:a :b :c :d) :e))
(= :a (peek '(:a :b :c :d :e)))
(= '(:b :c :d :e) (pop '(:a :b :c :d :e)))
(= "No dice!" (try
          (pop '())
          (catch IllegalStateException e
            "No dice!")))
(= '() (try
          (rest '())
          (catch IllegalStateException e
            "No dice!"))))

;;4

(= 1 (count [42]))
(= [1] (vec '(1)))
(= [nil,nil] (vector nil nil))
(= [1 2] (vec '(1 2)))
(= [111 222 333] (conj [111 222] 333))
(= :peanut (first [:peanut :butter :and :jelly]))
(= :jelly (last [:peanut :butter :and :jelly]))
(= :jelly (nth [:peanut :butter :and :jelly] 3))
(= [:butter :and] (subvec [:peanut :butter :and :jelly] 1 3))
(= (list 1 2 3) (vector 1 2 3)))

;;5

(= #{3} (set '(3)))
(= 3 (count #{1 2 3}))
(= #{1 2 3 4 5} (set '(1 1 2 2 3 3 4 4 5 5)))
(= #{1 2 3 4 5} (clojure.set/union #{1 2 3 4} #{2 3 5}))
(= #{2 3} (clojure.set/intersection #{1 2 3 4} #{2 3 5}))
(= #{1 4} (clojure.set/difference #{1 2 3 4 5} #{2 3 5}))

;;6

(= {:a 1 :b 2} (hash-map :a 1 :b 2))
(= {:a 1} (hash-map :a 1))
(= 2 (count {:a 1 :b 2}))
(= 2 (get {:a 1 :b 2} :b))
(= 1 ({:a 1 :b 2} :a))
(= 1 (:a {:a 1 :b 2}))
(= "Sochi" ({2010 "Vancouver" 2014 "Sochi" 2018 "PyeongChang"} 2014))
(= nil (get {:a 1 :b 2} :c))
(= :key-not-found (get {:a 1 :b 2} :c :key-not-found))
(= true (contains? {:a nil :b nil} :b))
(= false (contains? {:a nil :b nil} :c))
(= {1 "January" 2 "February"} (assoc {1 "January"} 2 "February"))
(= {1 "January"} (dissoc {1 "January" 2 "February"} 2))
(= {:a 1 :b 2 :c 3} (merge {:a 1 :b 2} {:c 3}))
(= {:a 1 :b 2 :c 3} (merge-with + {:a 1 :b 1} {:b 1 :c 3}))
(= (list 2010 2014 2018)
     (sort (keys { 2014 "Sochi" 2018 "PyeongChang" 2010 "Vancouver"})))
(= (list "PyeongChang" "Sochi" "Vancouver")
     (sort (vals {2010 "Vancouver" 2014 "Sochi" 2018 "PyeongChang"})))
(= {:a 2 :b 3}
     (into {}
           (map
            (fn [[k v]] [k (inc v)])
            {:a 1 :b 2}))))

;;7

(defn multiply-by-ten [n]
  (* 10 n))

(defn square [n] (* n n))

(= 81 (square 9))
(= 20 (multiply-by-ten 2))
(= 10 ((fn [n] (* 5 n)) 2))
(= 60 (#(* 15 %) 4))
(= 15 (#(+ %1 %2 %3) 4 5 6))
(= "AACC" (#(str "AA" %2) "bb" "CC"))
(= 9 (((fn [] +)) 4 5))
(= 20 ((fn [f] (f 4 5))
           *))
(= 25 (#(% 5)
          (fn [n] (* n n))))
(= 25 (#(% 5) square))

;;8

(= :a (if (false? (= 4 5))
          :a
          :b))
(= [](if (> 4 3)
          []))
(= nil (if (nil? 0)
          [:a :b :c]))
(= :glory (if (not (empty? ()))
              :doom
              __))
(= :glory (if (not (empty? ()))
              :doom
              :glory))
(let [x 5]
    (= :your-road (cond (= x 10) :road-not-taken
                        (= x 20) :another-road-not-taken
                        :else :your-road)))
(= 'doom (if-not (zero? 213)
          'doom
          'more-doom))
(= "pretty fast"
     (explain-exercise-velocity :bicycling))
(= "is that even exercise?"
     (explain-exercise-velocity :watching-tv))

;;9

(= [4 8 12] (map (fn [x] (* 4 x)) [1 2 3]))
(= [1 4 9 16 25] (map (fn [x] (* x x)) [1 2 3 4 5]))
(= '(false false true false false) (map nil? [:a :b nil :c :d]))
(= '() (filter (fn [x] false) '(:anything :goes :here)))
(= '(:anything :goes :here) (filter (fn [x] true) '(:anything :goes :here)))
(= [10 20 30] (filter (fn [x] (<= x 30)) [10 20 30 40 50 60 70 80]))
(= [10 20 30] (map (fn [x] (* x 10)) (filter (fn [x] (<= x 3)) [1 2 3 4 5 6 7 8])))
(= 24 (reduce (fn [a b] (* a b)) [1 2 3 4]))
(= 2400 (reduce (fn [a b] (* a b)) (* 100) [1 2 3 4]))
(= "longest" (reduce (fn [a b]
                         (if (< (count a) (count b)) b a))
                       ["which" "word" "is" "longest"]))

;;10

(defmulti diet (fn [x] (:eater x)))
(defmethod diet :herbivore [a] (str (:name a) " eats veggies."))
(defmethod diet :carnivore [a] (str (:name a) " eats animals."))
(defmethod diet :default [a] (str "I don't know what " (:name a) " eats."))

(= "Hello World!" (hello))
(= "Hello, you silly world." (hello "world"))
(= "Hello to this group: Peter, Paul, Mary!" (hello "Peter" "Paul" "Mary"))
(= "Bambi eats veggies."
     (diet {:species "deer" :name "Bambi" :age 1 :eater :herbivore}))
(= "Thumper eats veggies."
     (diet {:species "rabbit" :name "Thumper" :age 1 :eater :herbivore}))
(= "Simba eats animals."
     (diet {:species "lion" :name "Simba" :age 1 :eater :carnivore}))
(= "I don't know what Rich Hickey eats."
     (diet {:name "Rich Hickey"}))

;;11

(= [1 2 3 4] (range 1 5))
(= [0 1 2 3 4] (range 5))
(= [0 1 2 3 4 5 6 7 8 9]
     (take 10 (range 100)))
(= [95 96 97 98 99]
     (drop 95 (range 100)))
(= [1 2 4 8 16 32 64 128] (take 8 (iterate (fn [x] (* x 2)) 1)))
(= [:a :a :a :a :a :a :a :a :a :a]
     (repeat 10 :a))
(= (repeat 100 "hello")
     (take 100 (iterate fn "hello")))
(= (repeat 100 "hello")
   (take 100 (iterate "hello")))

;;12

(= [0 1 2 3 4 5]
     (for [x (range 6)]
       x))
(= '(0 1 4 9 16 25)
     (map (fn [x] (* x x))
          (range 6))
     (for [x (range 6)]
       (* x x)))
(= '(1 3 5 7 9)
     (filter odd? (range 10))
     (for [x (range 10) :when (odd? x)]
       x))
(= '(1 9 25 49 81)
   (map (fn [x] (* x x))
        (filter odd? (range 10)))
   (for [x (range 10) :when (odd? x)]
     (* x x)))
(= [[:top :left] [:top :middle] [:top :right]
    [:middle :left] [:middle :middle] [:middle :right]
    [:bottom :left] [:bottom :middle] [:bottom :right]]
   (for [row [:top :middle :bottom]
         column [:left :middle :right]]
     [row column]))

;;13

(defn square [x] (* x x))
(= [true false true] 
   (let [not-a-symbol? (complement symbol?)]
     (map not-a-symbol? [:a 'b "c"])))
(= [:wheat "wheat" 'wheat]
       (let [not-nil? (complement nil?)]
         (filter not-nil? [nil :wheat nil "wheat" nil 'wheat nil])))
(= 20
   (let [multiply-by-5 (partial * 5)]
     (multiply-by-5 4)))
(= [:a :b :c :d]
   (let [ab-adder (partial concat [:a :b])]
     (ab-adder [:c :d])))
(= 25 (let [inc-and-square (comp square inc)]
          (inc-and-square 4)))
(= 8 (let [double-dec (comp dec dec)]
          (double-dec 10)))
(= 99 (let [square-and-dec ___]
          (square-and-dec 10))))
(= 99
   (let [square-and-dec (fn [x] (dec (* x x)))]
     (square-and-dec 10)))

;;14

(defn is-even? [n]
  (if (= n 0)
    true
    (not (is-even? (dec n)))))

(defn is-even-bigint? [n]
  (loop [n n acc true]
    (if (= n 0)
      acc
      (recur (dec n) (not acc)))))

(defn recursive-reverse [coll]
  (if (empty? coll)
    '()
    (concat (recursive-reverse (rest coll)) [(first coll)])))

(defn factorial [n]
  (loop [n n acc 1N]
    (if (<= n 1)
      acc
      (recur (dec n) (* acc n)))))

(= true (is-even? 0))
(= false (is-even? 1))
(= false (is-even-bigint? 100003N))
(= '(1) (recursive-reverse [1]))
(= '(6 5 4 3 2) (recursive-reverse [2 3 4 5 6]))
(= 1 (factorial 1))
(= 2 (factorial 2))
(= 6 (factorial 3))
(= 24 (factorial 4))
(< 1000000000000000000000000N (factorial 1000N))
(< 1000000000000000000000000N (factorial 100003N)))

;;15

(def test-address
  {:street-address "123 Test Lane"
   :city "Testerville"
   :state "TX"})
  (= ":bar:foo" ((fn [[a b]] (str b a))
         [:foo :bar]))
  (= (str "An Oxford comma list of apples, "
          "oranges, "
          "and pears.")
     ((fn [[a b c]] (str "An Oxford comma list of " a ", " b ", and " c "."))
      ["apples" "oranges" "pears"]))
  (= "Rich Hickey aka The Clojurer aka Go Time aka Lambda Guru"
     (let [[first-name last-name & aliases]
           (list "Rich" "Hickey" "The Clojurer" "Go Time" "Lambda Guru")]
       (str first-name " " last-name " aka " (clojure.string/join " aka " aliases))))
  (= {:original-parts ["Stephen" "Hawking"] :named-parts {:first "Stephen" :last "Hawking"}}
     (let [[first-name last-name :as full-name] ["Stephen" "Hawking"]]
       {:original-parts full-name :named-parts {:first first-name :last last-name}}))
  (= "123 Test Lane, Testerville, TX"
     (let [{street-address :street-address, city :city, state :state} test-address]
       (str street-address ", " city ", " state)))
  (= "123 Test Lane, Testerville, TX"
     (let [{:keys [street-address city state]} test-address]
       (str street-address ", " city ", " state)))
  (= "Test Testerson, 123 Test Lane, Testerville, TX"
     ((fn [[f-name l-name] {:keys [street-address city state]}] 
        (str f-name " " l-name ", " street-address ", " city ", " state)) 
      ["Test" "Testerson"] test-address))

;;16

(def the-world (ref "hello"))
(def bizarro-world (ref {}))

  (= "hello" (deref the-world))
  (= "hello" @the-world)
  (= "better" (do
          (dosync (ref-set the-world "better"))
          @the-world))
  (= "better!!!" (let [exclamator (fn [x] (str x "!"))]
          (dosync
           (alter the-world exclamator)
           (alter the-world exclamator)
           (alter the-world exclamator))
          @the-world))
  (= 0 (do (dosync (ref-set the-world 0))
           @the-world))
  (= 20 (do
          (dosync (alter the-world (fn [x] 20)))))
  (= ["Real Jerry" "Bizarro Jerry"]
       (do
         (dosync
          (ref-set the-world {})
          (alter the-world assoc :jerry "Real Jerry")
          (alter bizarro-world assoc :jerry "Bizarro Jerry")
          [(:jerry @the-world) (:jerry @bizarro-world)])))

;;17

(def atomic-clock (atom 0))
  (= 0 @atomic-clock)
  (= 1 (do
          (swap! atomic-clock inc)
          @atomic-clock))
  (= 5 (do
         (swap! atomic-clock (fn [x] 5))
         @atomic-clock))
  (= 20 (do
          (swap! atomic-clock + 1 2 3 4 5)
          @atomic-clock))
  (= 20 (do
          (compare-and-set! atomic-clock 100 :fin)
          @atomic-clock))
  (= :fin (do
            (compare-and-set! atomic-clock 20 :fin)
            @atomic-clock))

;;20

  (= java.lang.String (class "warfare"))
  (= "SELECT * FROM" (.toUpperCase "select * from"))
  (= ["SELECT" "FROM" "WHERE"] (map #(.toUpperCase %) ["select" "from" "where"]))
  (= 10 (let [latch (java.util.concurrent.CountDownLatch. 10)]
          (.getCount latch)))
  (== 1024 (Math/pow 2 10))
